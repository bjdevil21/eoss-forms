Migrate API - Notes from https://youtu.be/3fG4wBvLrOI (Denver 2012 DrupalCon presentation)

* hook_migrate_api
  - Values available to __construct($arguments) in your Migrate classes are ultimately
set in $api['migrations'] array.

* Migration maps
  - Allows you to look up the old, source IDs based on the destination IDs - AFTER the migration
    that created the map is completed. Allows rollbacks, etc.

###############
Non-video notes:

* To do a basic migration, you need a source class and a destination class (a destination handler).
* There are examples of both online.

  ** Find a destination handler class that someone has already created for the type of node/entity that you're
    planning on migrating into. See migrate_examples as a good starting point.
    - Destination classes will always come out of MigrateDestination.

  ** Also look for a source class online for a starting point. Many of these exist in the Migrate and Migrate Extras
    module(s).
    Back to video...
###############

  You only need to set the following in your source class:

  * __construct:
    - $this->source
      - Pass in a Database API-written $query into the source class of choice
      - (usually MigrateSourceSQL($query))

    - $this->destination
      - Pass in a new class instantiation - new MigrateDestinationNode('<contentType'), etc.
      - Not all classes here need arguments... Look at the class in question for more info.

    - $this->map
      - Used for passing in schema of your keyed rows (usually IDs - uid, nid, etc.)
      - Ex. $this->map = new MigrateSQLMap(

      Parameters:
      - $this->machineName, - set this in the arguments array.
      - array(), - array with the SOURCE DB schema (see hook_schema) for your IDs
      - array(), - Contains the DESTINATION DB schema (see hook schema)
        - There's usually a helper function provided by destination code
        - Ex. MigrateDestinationTerm::getKeySchema()

    - $this->addFieldMapping('dest', 'src');
      - Maps an individual src field to the dest. field
      - This can take ->arguments($arguments)... This is used when multiple source fields
      - or values need to be passed into a single destination field. (Ex. body->summary,
      - body->format, etc. - all part of node->body.
      - Workaround: pass an array into arguments() and use key => value pairs to pass in that data.
      - See https://www.drupal.org/node/1012810 for more possible workarounds for this.
      - https://youtu.be/3fG4wBvLrOI?t=1257
      - Advanced functions that help utilize mappings
        - https://www.drupal.org/node/1133448

(These values generally coincide with the four top level Migrate classes (alongside Migration and MigrationBase])
  - MigrateSource
  - MigrateDestination
  - MigrateMap
  - MigrateFieldMapping)

* Dependencies

When you set a migration dependency, you have to run that migration BEFORE the current migration can be run.
(Set this in $arguments.)
  - Ex. You have the old IDs from the source and you want to get new IDs for users in the destination:
    - $this->addFieldMapping('uid', 'old_id')->sourceMigration('<previousMigration>');
    - $this->dependencies = array('<previousMigration>');

* Circular dependencies (need the user profile that doesn't exist yet for that billing table,
and you need the billing info for the user profile).

    - SOLUTION FOR THESE: Add a sourceMigration('<otherMigration>') method call to your <currentMigration> class
    (like above), then add createStub($currentMigration, $source_key) method call to your
    <otherMigration> class.

    - Flow: currentMigration runs before otherMigration. When currentMigration comes to the fieldMapping step,
     it will temporarily jump to otherMigration, which runs for one iteration and ONLY creates a database stub.
     It then immediately jumps back to currentMigration to continue its iteration. The created stub that will be
     fully populated as an update (vs create/insert) when otherMigration runs later.

    - Another way of saying this: This creates a new but empty record that gives you that new ID. When
    <previousMigration> runs, it'll go to the $migration (the "2nd" migration) and create the record stub.
    Then when the 2nd migration runs later, it updates and populate the stub record with the right info.
    (Denver video time: https://youtu.be/3fG4wBvLrOI?t=1503)
    * Drupal.org further explanation (along with alternate way to do this) - https://www.drupal.org/node/1013506

##############
non-video notes:
Great stubs resource:
https://www.drupal.org/node/1013506
back to video
##############

* Additional, important methods in your Migrate source class (after __construct method)
  - These are presented in execution order):

  1 prepareRow($row) -- Add or change values by editing the $row object properties, which
    contains your raw SQL data for that record (keyed by SQL col name by default)
    - Can skip this record by return FALSE based on any if/then PHP logic you want to use.
    ..THEN..

  2 the field handlers modify the values into a more Drupal-friendly value (nested arrays, etc.)
    ..THEN..

  3 prepare($entity, $row) -- Can edit the now Drupal-generated entity ($entity) before
  - Drupal finally saves it.
    - The $row object is available for reference, but editing it does nothing.
    - THEN the $entity is saved by the destination (handlers?)
    ..THEN..

  4 complete($ent, $row) -- Post-import processing for doing other work RELATED TO the
    newly-minted entity $ent, like adding roles to a new user, etc.
    - The new $entity ID is now available for viewing, if needed.
    - You shouldn't have to save anything related to the entity. If so, you're doing it wrong.
    ..THEN..

  5 The migration map is updated with the old and new IDs (based on what schema is defined
    in the map).
    ..DONE!

  - There are other methods that are required by the process, but they are USUALLY set and handled in
    parent classes.

END OF VIDEO
#########################